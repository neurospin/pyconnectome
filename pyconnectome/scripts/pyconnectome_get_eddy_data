#!/usr/bin/env python
##########################################################################
# NSAp - Copyright (C) CEA, 2018
# Distributed under the terms of the CeCILL-B license, as published by
# the CEA-CNRS-INRIA. Refer to the LICENSE file or to
# http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html
# for details.
##########################################################################

# System imports
import os
import glob
import argparse
import re
import json
import textwrap
import time
import subprocess
from argparse import RawTextHelpFormatter
from datetime import datetime
from pprint import pprint


# Bredala import
try:
    import bredala
    bredala.USE_PROFILER = False
    bredala.register("pyconnectomist.utils.dwitools",
                     names=["read_bvals_bvecs"])
    bredala.register("pyconnectome.utils.preproctools",
                     names=["concatenate_volumes", "get_dcm_info",
                            "get_readout_time", "get_dwell_time"])
except:
    pass


# Third-party imports
import numpy
import nibabel
import dicom
import progressbar

# Package import
from pyconnectome import __version__ as version
from pyconnectome.utils.preproctools import concatenate_volumes
from pyconnectome.utils.preproctools import get_dcm_info
from pyconnectome.utils.preproctools import get_readout_time
from pyconnectome.utils.preproctools import get_dwell_time


# Script documentation
DOC = """
Summarize subject data from DICOMs files
----------------------------------------

Summarize subject data from dicoms, and write a JSON output with information
such as scanner data, echo spacing, etc.

Requirements:
    - DWI file(s) path (required).
    - Associated .bval and .bvec files (required)
    - Associated DICOMs (required).
    - Assocaited T1 file (required)

For one subject:
    1) Create subject output directory
    2) If multiple dwi volumes are available, concatenate the volumes and their
       respective bval/bvec files.
    3) Unzip DICOMs (if necessary), and get scanner information.
    4) Get phase encoded direction.
    5) Write eddy acqp and index files in subject output directory.

Write the subject output as a json file.

Command example on the MAPT data:

python $HOME/git/pyconnectome/pyconnectome/scripts/pyconnectome_get_eddy_data \
    -s 03990185BAI \
    -c CENTER1 \
    -m /neurospin/cati/cati_shared/MAPT/CONVERTED/0399/03990185BAI/M0/MRI/DWI/03990185BAI_M0_DWI_1_S014.tar.gz \
    -d /neurospin/cati/cati_shared/MAPT/CONVERTED/0399/03990185BAI/M0/MRI/DWI/03990185BAI_M0_DWI_1_S014.nii.gz /neurospin/cati/cati_shared/MAPT/CONVERTED/0399/03990185BAI/M0/MRI/DWI/03990185BAI_M0_DWI_2_S019.nii.gz \
    -b /neurospin/cati/cati_shared/MAPT/CONVERTED/0399/03990185BAI/M0/MRI/DWI/03990185BAI_M0_DWI_1_S014.bval /neurospin/cati/cati_shared/MAPT/CONVERTED/0399/03990185BAI/M0/MRI/DWI/03990185BAI_M0_DWI_2_S019.bval \
    -r /neurospin/cati/cati_shared/MAPT/CONVERTED/0399/03990185BAI/M0/MRI/DWI/03990185BAI_M0_DWI_1_S014.bvec /neurospin/cati/cati_shared/MAPT/CONVERTED/0399/03990185BAI/M0/MRI/DWI/03990185BAI_M0_DWI_2_S019.bvec \
    -o /tmp/mapt \
    -V 2

Command example on the SENIOR data:

python $HOME/git/pyconnectome/pyconnectome/scripts/pyconnectome_get_eddy_data \
    -s ag160127 \
    -c CENTER1 \
    -m /neurospin/acquisition/database/Prisma_fit/20160707/ag160127-5226_001/000011_DTI \
    -d /neurospin/senior/nsap/data/V0/nifti/ag160127/000011_DTI/000011_DTI.nii.gz \
    -b /neurospin/senior/nsap/data/V0/nifti/ag160127/000011_DTI/000011_DTI.bvals \
    -r /neurospin/senior/nsap/data/V0/nifti/ag160127/000011_DTI/000011_DTI.bvecs \
    -o /tmp/senior \
    -V 2
"""


def is_file(filepath):
    """ Check file's existence - argparse 'type' argument.
    """
    if not os.path.isfile(filepath):
        raise argparse.ArgumentError("File does not exist: %s" % filepath)
    return filepath


def is_directory(dirarg):
    """ Type for argparse - checks that directory exists.
    """
    if not os.path.isdir(dirarg):
        raise argparse.ArgumentError(
            "The directory '{0}' does not exist!".format(dirarg))
    return dirarg


# Parse input arguments
def get_cmd_line_args():
    """
    Create a command line argument parser and return a dict mapping
    <argument name> -> <argument value>.
    """
    parser = argparse.ArgumentParser(
        prog="pyconnectome_get_eddy_data",
        description=textwrap.dedent(DOC),
        formatter_class=RawTextHelpFormatter)

    # Required arguments
    required = parser.add_argument_group("required arguments")
    required.add_argument(
        "-s", "--subject",
        required=True,
        help="The subject name.")
    required.add_argument(
        "-c", "--center",
        required=True,
        help="The center name.")
    required.add_argument(
        "-m", "--dicom",
        required=True, metavar="<path>",
        help="A compressed tarball (.tar.gz) or a folder containing the dMRI "
             "DICOM files or the DWI image BIDS description file. We assume "
             "that all images were acquired with the same protocol.")
    required.add_argument(
        "-d", "--dwi",
        required=True, metavar="<path>", nargs="+", type=is_file,
        help="Path to the DWI image files.")
    required.add_argument(
        "-b", "--bval",
        required=True, metavar="<path>", nargs="+", type=is_file,
        help="Path to the DWI asscoaited bval files.")
    required.add_argument(
        "-r", "--bvec",
        required=True, metavar="<path>", nargs="+", type=is_file,
        help="Path to the DWI asscoaited bvec files.")
    required.add_argument(
        "-o", "--outdir",
        required=True, metavar="<path>", type=is_directory,
        help="Subject output directory.")

    # Optional argument
    parser.add_argument(
        "-R", "--round-readout-time", action="store_true",
        help="Round read out time value to 3 digits after the decimal point.")
    parser.add_argument(
        "-V", "--verbose",
        type=int, choices=[0, 1, 2], default=2,
        help="Increase the verbosity level: 0 silent, [1, 2] verbose.")

    # Create a dict of arguments to pass to the 'main' function
    args = parser.parse_args()
    kwargs = vars(args)
    verbose = kwargs.pop("verbose")
    return kwargs, verbose


"""
Parse the command line.
"""
inputs, verbose = get_cmd_line_args()
runtime = {
    "tool": "pyconnectome_get_eddy_data",
    "tool_version": version,
    "timestamp": datetime.now().isoformat()}
outputs = None
if verbose > 0:
    pprint("[info] Starting EDDY data summary...")
    pprint("[info] Runtime:")
    pprint(runtime)
    pprint("[info] Inputs:")
    pprint(inputs)


"""
Summarize subject data from dicoms.
"""
# Create output data structure
subject_data = {
    "id": inputs["subject"],
    "center": inputs["center"]}

# Create output directory
output_sub_dir = os.path.join(inputs["outdir"], inputs["subject"])
if not os.path.isdir(output_sub_dir):
    os.mkdir(output_sub_dir)
subject_data["output_dir"] = output_sub_dir

# Concatenate the volume into new nii/bvec/bval files.
concat_volume, concat_bvals, concat_bvecs = concatenate_volumes(
    nii_files=inputs["dwi"],
    bvals_files=inputs["bval"],
    bvecs_files=inputs["bvec"],
    outdir=output_sub_dir,
    axis=-1)
subject_data["dwi"] = concat_volume
subject_data["bvec"] = concat_bvecs
subject_data["bval"] = concat_bvals

# Get read out time, phase encode dir and scanner from dicoms.
dcm_info = None
if os.path.isfile(inputs["dicom"]):
    if inputs["dicom"].endswith(".tar.gz"):
        output_dicom_dir = os.path.join(output_sub_dir, "dicom")
        if not os.path.isdir(output_dicom_dir):
            os.mkdir(output_dicom_dir)
        cmd = ["tar", "-xzf", inputs["dicom"], "-C", output_dicom_dir]
        subprocess.check_call(cmd)
    elif inputs["dicom"].endswith(".json"):
        with open(inputs["dicom"], "rt") as open_file:
            dcm_info = json.load(open_file)
    else:
        raise ValueError("Unexpected file format: '{0}'.".format(
            inputs["dicom"]))
else:
    output_dicom_dir = inputs["dicom"]

# Load a dicom file
if dcm_info is None:
    dicom_files = glob.glob(os.path.join(output_dicom_dir, "*"))
    if len(dicom_files) == 0:
        raise ValueError("No files in '{0}'.".format(output_dicom_dir))
    dicom_img = dicom.read_file(dicom_files[0])

    # Get dicom information
    dcm_info = get_dcm_info(
        dicom_dir=output_dicom_dir,
        outdir=output_sub_dir)

if "PhaseEncodingDirection" in dcm_info.keys():
    subject_data["PhaseEncodingDirection"] = dcm_info["PhaseEncodingDirection"]
elif "PhaseEncodingAxis" in dcm_info.keys():
    subject_data["PhaseEncodingAxis"] = dcm_info["PhaseEncodingAxis"]
else:
    raise ValueError("No information on phase encode direction...")

subject_data["Manufacturer"] = dcm_info["Manufacturer"]
subject_data["MagneticFieldStrength"] = dcm_info["MagneticFieldStrength"]

# Get dwell time (effective echo spacing)
dwell_time = get_dwell_time(
    dicom_img=dicom_img,
    dcm_info=dcm_info)
subject_data["DwellTime"] = dwell_time

# Get read out time
readout_time = get_readout_time(
    dicom_img=dicom_img,
    dcm_info=dcm_info,
    dwell_time=dwell_time)

if inputs["round_readout_time"]:
    readout_time = round(readout_time, 3)
subject_data["TotalReadoutTime"] = readout_time

# Write eddy acqp and index files
# https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/eddy/UsersGuide#A--acqp
acqp_file = os.path.join(output_sub_dir, "acqp.txt")
with open(acqp_file, "wt") as open_file:
    if dcm_info["Manufacturer"] in ["SIEMENS", "Siemens"]:
        if dcm_info["PhaseEncodingDirection"] == "i":
            open_file.write("1 0 0 {0}".format(readout_time))
        elif dcm_info["PhaseEncodingDirection"] == "i-":
            open_file.write("-1 0 0 {0}".format(readout_time))
        elif dcm_info["PhaseEncodingDirection"] == "j":
            open_file.write("0 1 0 {0}".format(readout_time))
        elif dcm_info["PhaseEncodingDirection"] == "j-":
            open_file.write("0 -1 0 {0}".format(readout_time))
        else:
            raise ValueError(
                "Unknown encode phase direction : {0}...".format(
                    dcm_info["PhaseEncodingDirection"]))
    else:
        print("Only phase encoding direction is assured for subject {0},"
              "orientation may be negative or positive.".format(
                inputs["subject"]))
        if dcm_info["PhaseEncodingAxis"] == "i":
            open_file.write("1 0 0 {0}".format(readout_time))
        elif dcm_info["PhaseEncodingAxis"] == "j":
            open_file.write("0 1 0 {0}".format(readout_time))
        else:
            raise ValueError(
                "Unknown encode phase direction : {0}...".format(
                    dcm_info["PhaseEncodingAxis"]))
subject_data["acqp"] = acqp_file

# Write index file
index_file = os.path.join(output_sub_dir, "index.txt")
nii_img = nibabel.load(subject_data["dwi"])
nb_volume = nii_img.get_data().shape[3]
with open(index_file, "wt") as open_file:
    for vol in range(nb_volume):
        open_file.write("1\t")
subject_data["index"] = index_file


"""
Write outputs
"""
# Write json
json_output = os.path.join(output_sub_dir, "info.json")
with open(json_output, "wt") as open_file:
    json.dump(subject_data, open_file, indent=4)


"""
Update the outputs and save them and the inputs in a 'logs' directory.
"""
logdir = os.path.join(output_sub_dir, "logs")
if not os.path.isdir(logdir):
    os.mkdir(logdir)
params = locals()
outputs = {"subject_data": json_output}
for name, final_struct in [("info_inputs", inputs), ("info_outputs", outputs),
                           ("info_runtime", runtime)]:
    log_file = os.path.join(logdir, "{0}.json".format(name))
    with open(log_file, "wt") as open_file:
        json.dump(final_struct, open_file, sort_keys=True, check_circular=True,
                  indent=4)
if verbose > 1:
    print("[info] Outputs:")
    pprint(outputs)
